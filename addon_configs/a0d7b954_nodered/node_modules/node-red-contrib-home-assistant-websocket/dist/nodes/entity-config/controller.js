"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __importDefault(require("events"));
const lodash_merge_1 = __importDefault(require("lodash.merge"));
const const_1 = require("../../const");
const globals_1 = require("../../globals");
const utils_1 = require("../../helpers/utils");
const nodeDefaults = {
    name: {},
    version: (nodeDef) => { var _a; return (_a = nodeDef.version) !== null && _a !== void 0 ? _a : 0; },
    server: {},
    haConfig: {},
    entityType: {},
};
class EntityConfigController extends events_1.default {
    constructor({ node, config }) {
        var _a, _b, _c, _d;
        super();
        this.registered = false;
        this.onHaEventsClose = () => {
            this.registered = false;
        };
        this.onHaEventsError = (err) => {
            var _a;
            this.node.error((_a = err.message) !== null && _a !== void 0 ? _a : err);
        };
        this.onHaIntegration = (type) => {
            switch (type) {
                case const_1.INTEGRATION_LOADED:
                    this.registerEntity();
                    break;
                case const_1.INTEGRATION_UNLOADED:
                case const_1.INTEGRATION_NOT_LOADED:
                    this.removeSubscription();
                    this.registered = false;
                    break;
            }
        };
        this.node = node;
        this.nodeConfig = (0, lodash_merge_1.default)({}, nodeDefaults, config);
        const serverNode = globals_1.RED.nodes.getNode(this.nodeConfig.server);
        this.server = serverNode.controller;
        // Setup event listeners
        node.on('close', this.onClose.bind(this));
        this.events = {
            'ha_client:close': this.onHaEventsClose,
            'ha_client:error': this.onHaEventsError,
            [const_1.INTEGRATION_EVENT]: this.onHaIntegration,
        };
        (0, utils_1.addEventListeners)(this.events, (_b = (_a = this.server) === null || _a === void 0 ? void 0 : _a.homeAssistant) === null || _b === void 0 ? void 0 : _b.eventBus);
        if ((_d = (_c = this.server) === null || _c === void 0 ? void 0 : _c.homeAssistant) === null || _d === void 0 ? void 0 : _d.isIntegrationLoaded) {
            this.registerEntity();
        }
    }
    async onClose(removed, done) {
        var _a, _b, _c, _d;
        // Remove event listeners
        (0, utils_1.removeEventListeners)(this.events, (_b = (_a = this.server) === null || _a === void 0 ? void 0 : _a.homeAssistant) === null || _b === void 0 ? void 0 : _b.eventBus);
        if (removed && ((_d = (_c = this.server) === null || _c === void 0 ? void 0 : _c.homeAssistant) === null || _d === void 0 ? void 0 : _d.isIntegrationLoaded)) {
            this.removeFromHomeAssistant();
        }
        this.removeSubscription();
        done();
    }
    getDiscoveryPayload(config = {}) {
        return {
            type: 'nodered/discovery',
            server_id: this.server.node.id,
            node_id: this.node.id,
            component: this.nodeConfig.entityType,
            config,
        };
    }
    async registerEntity() {
        var _a, _b;
        if (this.registered) {
            return;
        }
        const haConfig = {};
        const config = this.nodeConfig.haConfig;
        config
            .filter((c) => c.value.length)
            .forEach((e) => (haConfig[e.property] = e.value));
        try {
            const payload = this.getDiscoveryPayload(haConfig);
            this.node.debug(`Registering with Home Assistant`);
            this.subscription =
                await ((_b = (_a = this.server) === null || _a === void 0 ? void 0 : _a.homeAssistant) === null || _b === void 0 ? void 0 : _b.websocket.subscribeMessage(this.onHaEventMessage.bind(this), payload, { resubscribe: false }));
        }
        catch (e) {
            this.node.error(e.message);
            return;
        }
        this.registered = true;
    }
    onHaEventMessage(evt) {
        switch (evt === null || evt === void 0 ? void 0 : evt.type) {
            case 'automation_triggered':
                this.handleTriggerMessage(evt.data);
                break;
        }
    }
    async handleTriggerMessage(data = {}) {
        this.emit('triggered', data);
    }
    removeFromHomeAssistant() {
        var _a, _b;
        const payload = { ...this.getDiscoveryPayload(), remove: true };
        (_b = (_a = this.server) === null || _a === void 0 ? void 0 : _a.homeAssistant) === null || _b === void 0 ? void 0 : _b.websocket.send(payload);
        this.removeSubscription();
    }
    async removeSubscription() {
        if (this.subscription) {
            this.node.debug('Unregistering from HA');
            await this.subscription().catch(() => { }); // eslint-disable-line @typescript-eslint/no-empty-function
        }
        this.subscription = undefined;
    }
}
exports.default = EntityConfigController;
